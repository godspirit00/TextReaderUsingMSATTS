<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Text Reader using Microsoft Azure Text-to-speech</title>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="./audiobuffer-to-wav.js"></script>
    <style type="text/css">
        #t {
            width: 70%;
            height: 300px;
        }
    </style>
    <script type="text/javascript">
        const regionPrefix = "YOUR_REGION";
        var reqQueue = [];
        var audioQueue = [];
        var rate = 1;
        var playerPointer = -1;
        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var abQueue = [];
        var token = "";
        var tokenTime = 0;
        var cheapVoice = "";
        var staticAudio = [];

        function insertText(str) {  //Insert text at the cursor in a textarea
            let obj = $("#t").get(0);
            if (document.selection) {
                var sel = document.selection.createRange();
                sel.text = str;
            } else if (typeof obj.selectionStart === 'number' && typeof obj.selectionEnd === 'number') {
                var startPos = obj.selectionStart,
                    endPos = obj.selectionEnd,
                    cursorPos = startPos,
                    tmpStr = obj.value;
                obj.value = tmpStr.substring(0, startPos) + str + tmpStr.substring(endPos, tmpStr.length);
                cursorPos += str.length;
                obj.selectionStart = obj.selectionEnd = cursorPos;
            } else {
                obj.value += str;
            }
            $("#t").focus();
        }

        function wrapText(openTag, closeTag) {
            var textArea = $('#t');
            var len = textArea.val().length;
            var start = textArea[0].selectionStart;
            var end = textArea[0].selectionEnd;
            var selectedText = textArea.val().substring(start, end);
            var replacement = openTag + selectedText + closeTag;
            textArea.val(textArea.val().substring(0, start) + replacement + textArea.val().substring(end, len));
            $("#t").focus();
        }

        function insertTxt(text, index, insert) {
            let start = text.substring(0, index);
            let end = text.substring(index);
            return (start + insert + end);
        }

        function sleep(interval) {
            return new Promise(resolve => {
                setTimeout(resolve, interval);
            })
        }

        async function getToken() {
            console.log("Obtaining token...");
            let retryTimes = 3;
            let i;
            for (i = 0; i < retryTimes; i++) {
                await fetch("https://" + regionPrefix + ".api.cognitive.microsoft.com/sts/v1.0/issuetoken", {
                    method: "POST",
                    headers: {
                        "Ocp-Apim-Subscription-Key": "YOUR_SUBSCRIPTION_KEY",
                        "Content-Type": "application/x-www-form-urlencoded"
                    }
                }).then(res => {
                    if (!res.ok) {
                        i = 90;
                        throw new Error(res.statusText);
                    } else {
                        i = 99;
                        return res.text();
                    }
                }).then(restext => {
                    if (restext != "") {
                        token = restext;
                        console.log("Token retrieved. ");
                        tokenTime = new Date().getTime();
                    }
                }).catch(reason => {
                    console.log("Failed to get token." + reason);
                    if (i != 90 && i < retryTimes - 1) console.log("Retrying...");
                });
                await sleep(3000);
            }
            if (i < 99) {
                alert("Failed to obtain token.");
                return false;
            } else {
                return true;
            }

        }

        async function checkToken() {
            if (new Date().getTime() - tokenTime > 540000) {
                console.log("Token expired. Re-retrieving...");
                await getToken();
            }
        }

        function process(pre) {
            console.log("Start processing input... -->");
            var defaultVoice = $("body > #voice").val();
            var text = $("#t").val()
            var paras = [];
            rate = $("#speed").val();

            if (text.indexOf("<repeat ") != -1) {
                let findRepeat = new RegExp(/<repeat count='([\s\S]*?)'>([\s\S]*?)<\/repeat>/gmi);
                let result;
                let prevLastIndex = 0;
                while ((result = findRepeat.exec(text)) != null) {
                    if (prevLastIndex != result.index) paras.push(text.substring(prevLastIndex, result.index));
                    if (result[2].length > 200) {
                        for (let index = 0; index < Number(result[1]); index++) { //repeat the content in a very "direct" way ;-)
                            paras.push(result[2]);
                        }
                    } else {
                        let thistext = "";
                        for (let index = 0; index < Number(result[1]); index++) thistext += result[2];
                        paras.push(thistext);
                    }
                    prevLastIndex = findRepeat.lastIndex;
                }
                if (prevLastIndex != text.length) paras.push(text.substr(prevLastIndex));
            } else {
                paras.push(text);
            }

            for (let i = 0; i < paras.length; i++) {
                paras[i] = paras[i].trim();
                if (paras[i] != "") //not blank
                {
                    if (defaultVoice.indexOf("zh-CN") == -1) {
                        let findChinese = new RegExp(/(([0-9（“《\u4E00-\u9FA5\uFE30-\uFFA0]+[（“《\u4E00-\u9FA5\uFE30-\uFFA0]+[0-9（“《\u4E00-\u9FA5\uFE30-\uFFA0]+[，。？！”…》）\n]*)+)/gim);
                        while (findChinese.exec(paras[i]) != null) {
                            paras[i] = paras[i].replace(findChinese, "<voice name='" + $("#zh_CN > option:nth-child(1)").val() + "'>$1</voice>");
                            break;
                        }
                        let findDuplicate = new RegExp(/(<voice name=[\s\S]*?>)([0-9\., \u3002\uff1b\uff0c\uff1a\u201c\u201d\uff08\uff09\u3001\uff1f\u300a\u300b]*?)(<voice name=[\s\S]*?>)(([\u4E00-\u9FA5]|[\uFE30-\uFFA0])+)<\/voice>([0-9\., \u3002\uff1b\uff0c\uff1a\u201c\u201d\uff08\uff09\u3001\uff1f\u300a\u300b]*?)<\/voice>/gim);
                        paras[i] = paras[i].replace(findDuplicate, "$1$2$4$6</voice>");
                    }
                }
            }

            for (let i = 0; i < paras.length; i++) {
                if (paras[i] != "") //not blank
                {
                    let findBreak = new RegExp(/(<break [\s\S]*?\/>)/gim);
                    while (findBreak.exec(paras[i]) != null) {
                        paras[i] = paras[i].replace(findBreak, "<voice name='" + cheapVoice + "'>$1</voice>");
                        break;
                    }
                }
            }

            paras.forEach((element, index) => {
                if (element != "") {
                    element = element.replace(/<voice/gm, "<a");
                    element = element.replace(/<\/voice>/gm, "</a>");
                    let thistext = "<html><body><div>" + element + "</div></body></html>", xmlDoc = $.parseHTML(thistext), $xml = $(xmlDoc);
                    $xml.contents().filter(function () { return this.nodeType == 3 || this.nodeName.toLowerCase() != "a"; }).wrap('<a name=\"' + defaultVoice + '\"></a>');
                    let tmpStr = $xml.html();
                    tmpStr = tmpStr.replace(/<a name="[A-z\- ]*?">([\s]*?)<\/a>/gm, "$1");
                    tmpStr = tmpStr.replace(/<a /gm, "<voice ");
                    tmpStr = tmpStr.replace(/<\/a>/gm, "</voice>");
                    paras[index] = tmpStr;
                }
            });

            for (let index = 0; index < paras.length; index++) {
                const element = paras[index];
                const $xml = $("<xml>" + element + "</xml>");
                do {
                    var letscont = false;
                    $xml.find("voice").each(function () {
                        if ($(this).attr("name") == $(this).next().attr("name")) {
                            $(this).append($(this).next().html());
                            $(this).next().remove();
                            letscont = true;
                        }
                    });
                } while (letscont);
                paras[index]=$xml.html();
            }

            if (pre != undefined)  //For the express-as tag
            {
                return paras;
            }

            if (text.indexOf("<audio src=") != -1 || text.indexOf("<audio id=") != -1) {
                paras.forEach((element, index) => {
                    element = element.replace(/"><\/audio>/gmi, "\"/>");
                    let findAudio = new RegExp(/<audio (src||id)="[\s\S]+"\/>/gmi);
                    let result, insertCount = 0, tmpStr = element;
                    while ((result = findAudio.exec(element)) != null) {
                        tmpStr = insertTxt(tmpStr, result.index + insertCount * ("||".length), "||");
                        insertCount++;
                        tmpStr = insertTxt(tmpStr, findAudio.lastIndex + insertCount * ("||".length), "||");
                        insertCount++;
                    }
                    tmpStr = tmpStr.replace(/\|\|([\s]+)\|\|/gm, "$1||");
                    let tmpPara = tmpStr.split("||");

                    tmpPara.unshift(index, 1);
                    Array.prototype.splice.apply(paras, tmpPara);

                });
            }

            paras.forEach((element, index) => {
                let findVoicetag = new RegExp(/<\/voice>/gmi);
                let result, lastIndexes = [];
                while ((result = findVoicetag.exec(element)) != null) {
                    lastIndexes.push(findVoicetag.lastIndex);
                }
                if (lastIndexes.length > 5) //MS allows only 5 <voice> tags inside a request
                {
                    for (let i = 1; i < Math.ceil(lastIndexes.length / 5); i++) {
                        element = insertTxt(element, lastIndexes[i * 5 - 1] + (i - 1) * ("||".length), "||");
                    }
                    let tmpPara = element.split("||");

                    tmpPara.unshift(index, 1);
                    Array.prototype.splice.apply(paras, tmpPara);
                }
            });

            for (let index = 0; index < paras.length; index++) {
                if (paras[index] != "") {
                    let findEndofSent = new RegExp(/(: |\. |\? |! |\.\"|\?\"|!\"|：|。|？|！|。”|？”|！”|……)/gm);
                    let result;
                    let prevLastIndex = [0];
                    if (paras[index].length > 780) { //MS allows only 1000 chars in a request, with <speak...> counts up to 200 chars
                        while ((result = findEndofSent.exec(paras[index])) != null) {
                            prevLastIndex.push(findEndofSent.lastIndex);
                        }
                        let lastOffset = 0;
                        let subparaCount = 1;
                        for (let j = 0; j < prevLastIndex.length; j++) {
                            if (prevLastIndex[j] - lastOffset > 780) {
                                paras.splice(index + subparaCount, 0, paras[index].substring(lastOffset, prevLastIndex[j - 1]));
                                lastOffset = prevLastIndex[j - 1];
                                subparaCount++;
                                j--;
                            }
                        }
                        if (prevLastIndex.indexOf(lastOffset) < prevLastIndex.length - 1) {
                            paras.splice(index + subparaCount, 0, paras[index].substring(lastOffset));
                        }
                        paras.splice(index, 1);
                    }
                }
            }

            let startofTags = [];
            let startofTagsName = [];
            let startofTagsIndex = [];
            for (let i = 0; i < paras.length; i++) {
                if (paras[i] != "") {
                    let findStartofTag = new RegExp(/<(voice|prosody|mstts:express-as|p|s|phoneme|say-as|mstts:backgroundaudio)[\s\S]*?>/gmi);
                    let result;
                    while ((result = findStartofTag.exec(paras[i])) != null) {
                        startofTags.push(result[0]);
                        startofTagsName.push(result[1]);
                        startofTagsIndex.push(result.index);
                    }
                    if (startofTags.length > 0) {
                        if (paras[i].search(findStartofTag) != -1) {
                            for (let j = startofTags.length - 1; j >= 0; j--) {
                                if (paras[i].indexOf("</" + startofTagsName[j] + ">", startofTagsIndex[j]) != -1)  //This tag is closed.
                                {
                                    startofTagsName.splice(j, 1);
                                    startofTags.splice(j, 1);
                                    startofTagsIndex.splice(j, 1);
                                }
                            }
                            for (let j = startofTags.length - 1; j >= 0; j--) {
                                let tmpStr = paras[i].indexOf("<" + startofTagsName[j]) == -1 ? paras[i] : paras[i].substring(0, paras[i].indexOf("<" + startofTagsName[j]));
                                if (tmpStr.indexOf("</" + startofTagsName[j] + ">") != -1 && tmpStr.indexOf(startofTags[j]) == -1) { //Found the close tag of a tag started in prev para.
                                    paras[i] = startofTags[j] + paras[i];
                                    startofTagsName.splice(j, 1);
                                    startofTags.splice(j, 1);
                                    startofTagsIndex.splice(j, 1);
                                    continue;
                                }
                                if (paras[i].indexOf("</" + startofTagsName[j] + ">", startofTagsIndex[j]) == -1) {  //This tag is not closed. Add a temporal close tag.
                                    paras[i] += "</" + startofTagsName[j] + ">";
                                }
                            }

                        } else { //No start of tags found in this para
                            if (paras[i].search(/<\/[\S]*?>/) != -1) {
                                for (let j = startofTags.length - 1; j >= 0; j--) {
                                    if (paras[i].indexOf("</" + startofTagsName[j] + ">") != -1) {
                                        paras[i] = startofTags[j] + paras[i];
                                        startofTagsName.splice(j, 1);
                                        startofTags.splice(j, 1);
                                        startofTagsIndex.splice(j, 1);
                                    }
                                }
                            } else {
                                if (startofTags.length > 0) {
                                    for (let j = startofTags.length - 1; j >= 0; j--) {
                                        paras[i] = startofTags[j] + paras[i] + "</" + startofTagsName[j] + ">";
                                    }
                                }
                            }
                        }
                    }
                }
            }

            paras.forEach(element => {
                if (element.trim() != "") {
                    if (element.indexOf("mstts") == -1) {
                        reqQueue.push("<speak version=\"1.0\" xmlns=\"https://www.w3.org/2001/10/synthesis\" xml:lang=\"en-US\">" + element + "</speak>");
                    } else {
                        reqQueue.push("<speak version=\"1.0\" xmlns=\"https://www.w3.org/2001/10/synthesis\" xmlns:mstts=\"https://www.w3.org/2001/mstts\" xml:lang=\"en-US\">" + element + "</speak>");
                    }
                }
            });

            console.log("Now reqQueue looks like:" + reqQueue.join("||"));
            console.log("<-- Process complete.");
        }

        function optimizeReq() {
            reqQueue.forEach((element, index) => {
                reqQueue[index] = element.replace(/&/gm, " and ");
                reqQueue[index] = element.replace(/</gm, "&lt;");
                reqQueue[index] = element.replace(/>/gm, "&gt;");
                reqQueue[index] = element.replace(/'/gm, "&apos;");
                reqQueue[index] = element.replace(/"/gm, "&quot;");
                reqQueue[index] = element.replace(/	/gm, " ");
            });

            for (let index = 0; index < reqQueue.length; index++) {
                if (reqQueue[index].trim() == "") {
                    reqQueue.splice(index, 1);
                    index--;
                }
            }

            for (let i = 0; i < reqQueue.length; i++) {  //Rewrite JSON to reuse audio
                if (reqQueue[i].indexOf("<speak") != -1) {
                    for (let j = 0; j < reqQueue.length; j++) {
                        if (reqQueue[i] == reqQueue[j] && i > j) {
                            reqQueue[i] = "{ \"repeatLine\" : \"" + j + "\" }";
                        }
                    }
                }
            }


            console.log("reqQueue optimized. Now JSON queue looks like: " + reqQueue);
        }

        async function sendReq() {
            if (reqQueue.length > 0) {
                console.log("Sending requests to the server.");
                for (let i = 0; i < reqQueue.length; i++) {
                    console.log("Requesting line " + i + "...");
                    if (reqQueue[i].indexOf("<audio src=") != -1) {
                        let findAudio = new RegExp(/<audio src="([\s\S]+)"\/>/gmi);
                        let result = findAudio.exec(reqQueue[i]);
                        console.log("Loading external audio file: " + result[1]);
                        await fetch(result[1]).then(res => {
                            if (res.ok) {
                                return res.blob();
                            } else {
                                throw new Error(res.statusText);
                            }
                        }).then(resblob => {
                            if (resblob != undefined) {
                                console.log("Audio #" + i + " received.");
                                audioQueue.push(URL.createObjectURL(resblob));
                            }
                        }).catch(reason => {
                            console.log("Unable to load audio file: " + result[1] + ", " + reason);
                        });
                    } else if (reqQueue[i].indexOf("<audio id=") != -1) {
                        let findAudio = new RegExp(/<audio id="([0-9]+)"\/>/gmi);
                        let result = findAudio.exec(reqQueue[i]);
                        console.log("Loading staticAudio #" + result[1]);
                        audioQueue.push(staticAudio[Number(result[1])]);
                    } else if (reqQueue[i].indexOf("\"repeatLine\"") != -1) { //Reuse audio for same content
                        let thisjson = JSON.parse(reqQueue[i]);
                        audioQueue.push(audioQueue[Number(thisjson.repeatLine)]);
                        console.log("Reusing audio #" + thisjson.repeatLine + " for JSON #" + i);
                    } else {
                        let retryTimes = 3;
                        let index;
                        for (index = 0; index < retryTimes; index++) {
                            await fetch("https://" + regionPrefix + ".tts.speech.microsoft.com/cognitiveservices/v1", {
                                method: 'POST',
                                headers: {
                                    'X-Microsoft-OutputFormat': 'audio-24khz-160kbitrate-mono-mp3',
                                    'Content-Type': 'application/ssml+xml',
                                    'Authorization': 'Bearer ' + token
                                },
                                body: reqQueue[i]
                            }).then(res => {
                                if (res.ok) {
                                    index = 99;
                                    return res.blob();
                                } else {
                                    index = 90;
                                    throw new Error(res.statusText);
                                }
                            }).then(resblob => {
                                if (resblob != undefined) {
                                    console.log("Audio #" + i + " received.");
                                    audioQueue.push(URL.createObjectURL(resblob));
                                }
                            }).catch(reason => {
                                console.log("Failed to retrieve audio #" + i + ": " + reason + ".");
                                if (index != 90 && index < retryTimes - 1) console.log("Retrying...");
                            });
                            await sleep(3000);
                        }
                        if (index < 99) {
                            console.error("Failed to retrieve audio #" + i);
                        }
                    }
                }
                if (audioQueue.length != reqQueue.length) {
                    alert("Some lines are not synthesized correctly.");
                } else {
                    console.log("All audio has been retrieved.");
                }
                $("#saveit").removeAttr("disabled");  //saveit button state change
            } else {
                alert("Type in something first!");
            }
        }

        async function getVoices() {
            console.log("Requesting voice list...");
            let retryTimes = 3;
            let index;
            for (index = 0; index < retryTimes; index++) {
                await fetch("https://" + regionPrefix + ".tts.speech.microsoft.com/cognitiveservices/voices/list", {
                    method: 'GET',
                    headers: {
                        "Authorization": "Bearer " + token
                    }
                }).then(res => {
                    if (!res.ok) {
                        index = 90;
                        throw new Error(res.statusText);
                    } else {
                        index = 99;
                        return res.json();
                    }
                }).then(resjson => {
                    console.log("Voice list received. ");

                    for (const key in resjson) {
                        if (resjson[key].Locale.indexOf("en-US") != -1) {
                            if (resjson[key].VoiceType == "Neural") {
                                $("#en_US").append("<option value='" + resjson[key].ShortName + "'>(" + resjson[key].Gender + ") " + resjson[key].ShortName.replace(/(en-US-)([\s\S]*?)(Neural)/, "$2") + " </option>");
                            } else {
                                cheapVoice = resjson[key].ShortName;
                            }
                        } else if (resjson[key].Locale.indexOf("zh-CN") != -1) {
                            if (resjson[key].VoiceType == "Neural") {
                                $("#zh_CN").append("<option value='" + resjson[key].ShortName + "'>(" + resjson[key].Gender + ") " + resjson[key].ShortName.replace(/(zh-CN-)([\s\S]*?)(Neural)/, "$2") + " </option>");
                            }
                        }
                    }
                    //Submit button state change
                    $("#sub").removeAttr("disabled");
                }).catch(reason => {
                    console.log("Failed to get voice list. " + reason);
                    if (index != 90 && index < retryTimes - 1) console.log("Retrying...");
                });
                await sleep(3000);
            }
            if (index < 99) alert("Failed to retrieve voice list.");

        }

        async function joinAudio() {
            var ttlLength = 0;
            var sr;
            if (audioQueue.length <= 0) {
                alert("Speak it at least once first!");
                reject("No audio received yet.");
            } else {
                console.log("Begin Join Audio -->");
                for (let i = 0; i < audioQueue.length; i++) {
                    console.log("Process Audio #" + i);
                    await fetch(audioQueue[i]).then(function (response) {
                        if (!response.ok) {
                            throw new Error('HTTP error, status = ' + response.status);
                        } else {
                            return response.arrayBuffer();
                        }
                    }).then(async function (response) {
                        await audioCtx.decodeAudioData(response).then(function (buffer) {
                            var b = buffer.getChannelData(0);
                            //console.log (b.numberOfChannels);
                            abQueue.push(b);
                            ttlLength += b.length;
                            sr = buffer.sampleRate;
                        });

                    });

                }
                console.log("Total length: " + ttlLength);
                let resultBuffer = audioCtx.createBuffer(1, ttlLength, sr);
                let rbData = resultBuffer.getChannelData(0);

                var j = 0;
                for (let i = 0; i < abQueue.length; i++) {
                    await rbData.set(abQueue[i], j);
                    j += abQueue[i].length;
                }

                console.log("<-- End of Join Audio");

                return resultBuffer;
            }
        }

        async function saveAudio() {
            if (audioQueue.length <= 0) {
                alert("Speak it at least once first!");
            } else {
                try {
                    await joinAudio().then(function (b) {
                        console.log(b);

                        let wav = audioBufferToWav(b);
                        var blob = new Blob([new DataView(wav)], {
                            type: "audio/wav"
                        });
                        console.log(blob);
                        console.log("Triggering download...");
                        let a = document.createElement('a');
                        a.download = new Date().getTime().toString() + '.wav';
                        let dl = window.URL.createObjectURL(blob);
                        a.href = dl;
                        $("body").append(a);
                        a.click();
                        $(a).remove();
                        URL.revokeObjectURL(dl);
                    });
                } catch (error) {
                    alert("An error occured when exporting the audio: " + error);
                } finally {
                    $("#saveit").removeAttr("disabled");  //saveit button state change
                }
            }
        }
    </script>
</head>

<body>
    <h1>Text Reader using Microsoft Azure Text-to-speech</h1><br>
    Default voice: <select id="voice">
        <optgroup label="US English" id="en_US">
        </optgroup>
        <optgroup label="Mandarin Chinese" id="zh_CN">
        </optgroup>
    </select>
    &nbsp;&nbsp; <div style="display: none;"> Rate: <input type="range" id="speed" min="0.25" max="4.0" step="0.01">
        <input type="text" id="speedtxt"></div>
    <br>
    <button id="insertAudio">Insert audio file</button> <button id="insertPause">Insert Pause</button>
    <div id="showOnSelect"><button id="insertRepeat">Insert repeat</button> <button id="changevoice">Change
            voice</button>
        <button id="dlgmaker">Dialog Maker</button> <!-- <button id="insertEmph">Insert emphasis</button> --> <button
            id="insertProsody">Insert prosody</button> <button id="insertExpressAs">Adjust speaking styles</button>
    </div> <br>
    <textarea id="t" autofocus required spellcheck="false" placeholder="Enter text you wish spoken here."></textarea>
    <br>
    <button id="sub">Speak it!</button> <button id="saveit">Save audio to file</button>
    <br>
    <div id="choosevoicedlg" style="display: none;"><b>Choose a voice: </b>
        <div id="dlgvoicelist0"></div> <button id="dlgok0">OK</button> <button id="dlgcancel0">Cancel</button>
    </div>
    <div id="dlgmakerdlg" style="display: none;">Choose a voice for each character: <br>
        <div id="charlist"></div><button id="dlgok1">OK</button> <button id="dlgcancel1">Cancel</button>
    </div>
    <div id="emphasisdlg" style="display: none;">Choose an emphasis level: <select id="emphlvl">
            <option value="strong">Strong</option>
            <option value="moderate">Moderate</option>
            <option value="none" selected>None</option>
            <option value="reduced">Reduced</option>
        </select><br><button id="dlgok2">OK</button> <button id="dlgcancel2">Cancel</button></div>
    <div id="prosodydlg" style="display: none;">Set prosody:<br>Pitch:<input type="range" id="pitch" min="-8" max="8"
            value="0"> <input type="number" id="pitchtxt" max="8" min="-8" step="1">semitone <br> Rate: <input
            type="range" id="rate" min="0.5" max="5" value="1" step="0.01"> <input type="number" id="ratetxt" min="0.5"
            max="5" step="0.01" value="1"><br><button id="dlgok3">OK</button> <button id="dlgcancel3">Cancel</button>
    </div>
    <div id="expressdlg" style="display: none;">Adjust speaking styles: <br /><select id="expressstyle-j"
            style="display: none;">
            <option value="cheerful">Cheerful</option>
            <option value="empathy">Empathy</option>
            <option value="chat">Chat</option>
            <option value="newscast">News Cast</option>
            <option value="customerservice">Customer Service</option>
        </select>
        <select id="expressstyle-x" style="display: none;">
            <option value="newscast">Newscast</option>
            <option value="sentiment">Sentiment</option>
        </select><br><button id="dlgok4">OK</button> <button id="dlgcancel4">Cancel</button>
    </div>
    <div id="insertaudiofiledlg" style="display: none;">Insert audio file:
        <br />
        <div id="audiolist">
            <label> <input type="radio" name="a" id="audios" value="-1" checked> Pick a file: <input type="file"
                    id="audiofile" accept="audio/*"></label><br />
            <label> <input type="radio" name="a" id="audios" value="-2"><input type="url" id="audiourl"
                    placeholder="Enter URL to the audio file. e.g.: http://example.com/a.mp3" size="80"> </label><br />
        </div>

        <br><button id="dlgok5">OK</button> <button id="dlgcancel5">Cancel</button>
    </div>

    <script type="text/javascript">
        $(document).ready(function () {
            getToken().then(ok => {
                if (ok) getVoices();
            }).catch(e => { });
            //Submit button state change
            $("#sub").attr("disabled", "true");
            $("#sub").click(function () {
                if ($("#t").val().length <= 0) {
                    alert("Type in something first!");
                    return;
                }
                if (audioQueue.length <= 0) {

                    //Submit button state change
                    $("#sub").attr("disabled", "true");
                    $("#sub").text("Please wait...");

                    process();
                    optimizeReq();
                    checkToken().then(() => {
                        sendReq();
                    });
                } else {
                    if (player.ended && playerPointer >= audioQueue.length - 1) {
                        console.log("Audio already retrieved. Start playing.");
                        playerPointer = -1;
                        // Play audioQueue directly.

                        //Submit button state change
                        $("#sub").text("Pause");

                    } else {
                        if (!player.ended && player.paused) {
                            player.play();

                            //Submit button state change
                            $("#sub").text("Pause");
                        } else if (!player.ended && !player.paused) {
                            player.pause();

                            //Submit button state change
                            $("#sub").text("Resume");
                        }
                    }
                }
            });
            $("#speed").val("1.0");

            $("#showOnSelect").css("display", "none");

            const player = new Audio();
            player.loop = false;

            player.addEventListener("ended", () => {
                if (playerPointer >= audioQueue.length - 1) {
                    if (audioQueue.length > 0) {
                        //Submit button state change
                        $("#sub").text("Replay");
                    } else {
                        //Submit button state change
                        $("#sub").text("Speak it!");
                    }
                }
            });

            var docWatch = setInterval(function () {
                if (audioQueue.length > 0 && playerPointer < audioQueue.length - 1) //To make the audio start playing, audioQueue has to have sth, and playerPointer is -1.
                {
                    if (player.ended || (!player.ended && playerPointer == -1)) {
                        playerPointer++;
                        player.src = audioQueue[playerPointer];
                        console.log("Playing Audio #" + playerPointer);
                        player.play();

                        //Submit button state change
                        $("#sub").removeAttr("disabled");
                        $("#sub").text("Pause");
                    }
                }

                if (document.activeElement.id != "speedtxt") {
                    $("#speedtxt").val($("#speed").val());
                }
                if (document.activeElement.id != "ratetxt") { //for the prosody dlg
                    $("#ratetxt").val($("#rate").val());
                }
                if (document.activeElement.id != "pitchtxt") { //for the prosody dlg
                    $("#pitchtxt").val($("#pitch").val());
                }

                if ($("#t")[0].selectionStart != $("#t").get(0).selectionEnd) {
                    $("#showOnSelect").css("display", "inline");
                } else {
                    $("#showOnSelect").css("display", "none");
                }

            }, 100);
        });
        $("#saveit").attr("disabled", "true");  //saveit button state change
        $("#saveit").click(() => {
            if (reqQueue.length <= 0) {
                alert("Type in something and speak it first!");
            } else {
                if (audioQueue.length < reqQueue.length) {
                    alert("Please wait until all audio are retrieved.");
                } else {
                    $("#saveit").attr("disabled", "true");  //saveit button state change
                    saveAudio();
                }
            }
        });
        $("#t").change(function () {
            reqQueue = [];
            audioQueue = [];
            playerPointer = -1;
            abQueue = [];
            //Submit button state change
            $("#sub").text("Speak it!");
            $("#saveit").attr("disabled", "true");  //saveit button state change

            try { player.pause(); } catch (e) { }

        });
        $("#t").bind("input", () => $("#t").change());
        $("#voice").change(function () {
            $("#t").change();
        });
        $("#speedtxt").change(function () {
            $("#speed").val($("#speedtxt").val());
            $("#t").change();
        });
        $("#speed").change(function () {
            $("#t").change();
        })
        $("#ratetxt").change(function () { //for the prosody dlg
            $("#rate").val($("#ratetxt").val());
        });
        $("#pitchtxt").change(function () { //for the prosody dlg
            $("#pitch").val($("#pitchtxt").val());
        });


        $("#insertPause").click(() => {
            let pause = window.prompt("Pause for how long?" + "\n" + "e.g.:2s", "2s");
            if (pause != "" && pause != null) {
                if (pause.substr(pause.length - 1, 1) != "s") pause += "s";
                if (/([0-9]+)(ms|s)/.test(pause)) {
                    insertText("<break time=\"" + pause + "\" />");
                } else {
                    alert("Invalid input.");
                }
            }
        });
        $("#insertRepeat").click(() => {
            let count = window.prompt("Repeat how many times?", "2");
            if (count != "" && count != null) {
                if (Number(count) == NaN) {
                    alert("Invalid input.");
                } else {
                    wrapText("<repeat count='" + count + "'>", "</repeat>");
                }
            }
        });

        $("#changevoice").click(() => {
            if ($("#dlgvoicelist0 > #voice").val() == undefined) {
                $("#dlgvoicelist0").append($("body > #voice").clone());
            }
            $("#choosevoicedlg").css("display", "inline");
        });
        $("#dlgok0").click(() => {
            let v = $("#dlgvoicelist0 > #voice").val();
            wrapText("<voice name=\"" + v + "\">", "</voice>");
            $("#choosevoicedlg").css("display", "none");
        });
        $("#dlgcancel0").click(() => {
            $("#choosevoicedlg").css("display", "none");
        });

        $("#dlgmaker").click(() => {
            let t = $("#t");
            let tt = t.val();
            let st = tt.substring(t.get(0).selectionStart, t.get(0).selectionEnd);
            let stpara = st.split("\n");

            let chara = [];


            if (stpara.length < 2) {
                alert("I cannot make a conversation out of less than 2 lines.");
            } else {
                let goahead = true;
                for (let i = 0; i < stpara.length; i++) {
                    if (stpara[i].trim() == "") continue;

                    let curCharPos = stpara[i].search(/(:|：)/);
                    if (curCharPos == -1) {
                        alert("Line " + i + " does not contain a speaker indicator.");
                        goahead = false;
                        break;
                    } else {
                        let curChar = stpara[i].substring(0, curCharPos);
                        if (chara.join().indexOf(curChar) == -1) {
                            chara.push(curChar);
                        }
                    }
                }
                console.log("DialogMaker: Found characters: " + chara);
                if (goahead) {
                    for (let i = 0; i < chara.length; i++) {
                        $("#charlist").append("<p>" + chara[i] + " —— ");
                        $("#charlist").append($("body > #voice").clone());
                        $("#charlist").append("</p>");
                    }
                    $("#dlgmakerdlg").css("display", "inline");
                }

            }
        });
        $("#dlgok1").click(() => {
            let t = $("#t");
            let tt = t.val();
            let st = tt.substring(t.get(0).selectionStart, t.get(0).selectionEnd);
            let stpara = st.split("\n");

            let chara = [];
            let voices = [];


            if (stpara.length < 2) {
                alert("I cannot make a conversation out of less than 2 lines.");
            } else {
                let goahead = true;
                for (let i = 0; i < stpara.length; i++) {
                    if (stpara[i].trim() == "") continue;
                    if (stpara[i].search(/(:|：)/) == -1) {
                        alert("Line " + i + " does not contain a speaker indicator.");
                        goahead = false;
                        break;
                    } else {
                        chara.push(stpara[i].substring(0, stpara[i].search(/(:|：)/) + 1));
                    }
                }
                if (goahead) {
                    for (let i = 0; i < chara.length; i++) {
                        $("#charlist > #voice").each(function () {
                            voices.push($(this).val());
                        });
                    }
                    console.log("DialogMaker: Selected voices: " + voices);

                    for (let i = 0; i < stpara.length; i++) {
                        for (let j = 0; j < chara.length; j++) {
                            if (stpara[i].substring(0, stpara[i].search(/(:|：)/) + 1) == chara[j]) {
                                stpara[i] = stpara[i].replace(chara[j], "<voice name=\"" + voices[j] + "\">");
                                stpara[i] += " </voice>";
                                break;
                            }
                        }
                    }
                    console.log("DialogMaker: Paragraph processed: " + stpara);

                    st = stpara.join("\n");
                    $("#t").val(tt.substring(0, t.get(0).selectionStart) + st + tt.substring(t.get(0)
                        .selectionEnd));

                }

            }
            $("#dlgcancel1").click();
        });
        $("#dlgcancel1").click(() => {
            $("#dlgmakerdlg").css("display", "none");
            $("#charlist").empty();
        });

        $("#insertEmph").click(() => {
            $("#emphasisdlg").css("display", "inline");
        });
        $("#dlgok2").click(() => {
            let emph = $("#emphlvl").val();
            let t = $("#t");
            let tt = t.val();
            let st = tt.substring(t.get(0).selectionStart, t.get(0).selectionEnd);
            if (st.indexOf("\n") != -1) {
                alert("Please don't wrap multiple lines with the <emphasis> tag.");
            } else {
                wrapText("<emphasis level='" + emph + "'>", "</emphasis>");
            }
            $("#emphasisdlg").css("display", "none");
        });
        $("#dlgcancel2").click(() => {
            $("#emphasisdlg").css("display", "none");
        });

        $("#insertProsody").click(() => {
            let t = $("#t");
            let tt = t.val();
            let st = tt.substring(t.get(0).selectionStart, t.get(0).selectionEnd);
            if (st.indexOf("</voice>") != -1 || st.indexOf("<voice ") != -1) {
                alert("Please don't insert tags across the border of a <voice> tag.");
            } else {
                $("#prosodydlg").css("display", "inline");
            }
        });
        $("#dlgok3").click(() => {
            let rate = $("#rate").val();
            let pitch = $("#pitch").val();
            let tmpStr = "";
            if (Number(rate) != 1) tmpStr += " rate=\"" + rate + "\"";
            if (Number(pitch) != 0) tmpStr += " pitch=\"" + (Number(pitch) > 0 ? "\+" + pitch : pitch) + "st\"";
            wrapText("<prosody" + tmpStr + ">", "</prosody>");
            $("#dlgcancel3").click();
        });
        $("#dlgcancel3").click(() => {
            $("#prosodydlg").css("display", "none");
            $("#rate").val("100");
            $("#pitch").val("0");
        });

        $("#insertExpressAs").click(() => {
            let t = $("#t");
            let tt = t.val();
            let st = tt.substring(t.get(0).selectionStart, t.get(0).selectionEnd);
            if (st.indexOf("</voice>") != -1 || st.indexOf("<voice ") != -1 || st.indexOf("<repeat ") != -1 || st.indexOf("</repeat>") != -1) {
                alert("Please don't insert tags across the border of a <voice> or <repeat> tag.");
                return;
            }

            $("#expressdlg").css("display", "inline");
            let paras = process(1);
            let chara = "";
            paras.forEach((element, index) => {
                $("<xml><speak>" + element + "</speak></xml>").find("voice").each(function () {
                    if ($(this).text().indexOf(st) != -1) {
                        if ($(this).attr("name").indexOf("Jessa") != -1) {  //The only 2 voices that support the feature 
                            chara = "Jessa";
                        } else if ($(this).attr("name").indexOf("Xiaoxiao") != -1) {
                            chara = "Xiaoxiao";
                        } else {
                            alert("The selected voice for the selected text does not support this feature yet.");
                            chara = $(this).attr("name");
                            $("#dlgcancel4").click();
                        }
                        return false;
                    }
                });
                if (chara == "Jessa") {
                    $("#expressstyle-j").css("display", "inline");
                    return false;
                } else if (chara == "Xiaoxiao") {
                    $("#expressstyle-x").css("display", "inline");
                    return false;
                }
            });
            if (chara == "") {
                alert("Something odd happens. I don't know which voice is going to read this text.");
                $("#dlgcancel4").click();
            }
        });

        $("#dlgok4").click(() => {
            let thisstyle = "";
            if ($("#expressstyle-j").css("display") != "none") {
                thisstyle = $("#expressstyle-j").val();
            } else if ($("#expressstyle-x").css("display") != "none") {
                thisstyle = $("#expressstyle-x").val();
            } else {
                alert("Something odd happens. I don't know what style is selected.");
            }
            if (thisstyle != "") {
                wrapText("<mstts:express-as type=\"" + thisstyle + "\">", "</mstts:express-as>");
            }
            $("#dlgcancel4").click();
        });
        $("#dlgcancel4").click(() => {
            $("#expressstyle-j").css("display", "none");
            $("#expressstyle-x").css("display", "none");
            $("#expressdlg").css("display", "none");
        });

        $("#insertAudio").click(function () {
            $("#insertaudiofiledlg").css("display", "inline");
        });
        $("#dlgok5").click(() => {
            let s = $("#audios:checked").val();
            switch (s) {
                case "-1":
                    let file = $("#audiofile");
                    if (file.val() == "") {
                        alert("Choose a file, please.");
                        return;
                    } else {
                        let thisfile = file[0].files[0];
                        let id = staticAudio.push(URL.createObjectURL(thisfile)) - 1;
                        insertText("<audio id=\"" + id + "\"/>");
                        $("#audiolist").prepend("<label><input type='radio' name='a' id='audios' value='" + id + "' checked>  " + thisfile.name + "  <button onclick='new Audio(staticAudio[" + id + "]).play()'>Play</button></label><br />");
                        $("#dlgcancel5").click();
                    }
                    break;
                case "-2":
                    let url = $("#audiourl").val();
                    if (url != "") {
                        insertText("<audio src=\"" + url + "\"/>");
                        $("#dlgcancel5").click();
                    } else {
                        alert("Please enter the URL to the audio file.");
                        return;
                    }
                    break;
                default:
                    insertText("<audio id=\"" + s + "\"/>");
                    $("#dlgcancel5").click();
                    break;
            }
        });
        $("#dlgcancel5").click(() => {
            $("#audiofile").val("");
            $("#insertaudiofiledlg").css("display", "none");
        });
        $("label").click(() => {
            $(this).find("#audios").click();
        });
    </script>
</body>

</html>